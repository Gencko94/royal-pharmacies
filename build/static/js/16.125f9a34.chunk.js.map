{"version":3,"sources":["../../src/observers.ts","../../src/InView.tsx","../../src/useInView.tsx","../node_modules/swiper/esm/components/pagination/pagination.js","../node_modules/swiper/esm/components/autoplay/autoplay.js","../node_modules/use-debounce/esm/useDebouncedCallback.js"],"names":["ObserverMap","RootIds","rootId","optionsToId","options","Object","key","root","observe","element","callback","id","instance","elements","observer","IntersectionObserver","entries","inView","entry","thresholds","Array","createObserver","callbacks","isPlainChildren","props","InView","node","_unobserveCb","handleNode","undefined","handleChange","componentDidUpdate","prevProps","this","componentWillUnmount","observeNode","threshold","rootMargin","trackVisibility","delay","unobserve","render","children","ref","as","tag","useInView","triggerOnce","skip","initialInView","React","state","setState","setRef","useEffect","result","_extends","assign","target","i","arguments","length","source","prototype","hasOwnProperty","call","apply","Pagination","update","swiper","rtl","params","pagination","el","$el","current","slidesLength","virtual","enabled","slides","total","loop","Math","ceil","loopedSlides","slidesPerGroup","snapGrid","activeIndex","paginationType","snapIndex","type","bullets","firstIndex","lastIndex","midIndex","dynamicBullets","bulletSize","eq","isHorizontal","css","dynamicMainBullets","previousIndex","dynamicBulletIndex","min","removeClass","bulletActiveClass","each","bullet","$bullet","$","bulletIndex","index","addClass","prev","next","$firstDisplayedBullet","$lastDisplayedBullet","_i","dynamicBulletsLength","bulletsOffset","offsetProp","find","classesToSelector","currentClass","text","formatFractionCurrent","totalClass","formatFractionTotal","progressbarDirection","progressbarOpposite","scale","scaleX","scaleY","progressbarFillClass","transform","transition","speed","renderCustom","html","emit","watchOverflow","isLocked","lockClass","paginationHTML","numberOfBullets","freeMode","renderBullet","bulletClass","bulletElement","renderFraction","renderProgressbar","init","uniqueNavElements","clickable","clickableClass","modifierClass","progressbarOppositeClass","on","e","preventDefault","slideTo","extend","destroy","hiddenClass","off","name","hideOnClick","number","create","bindModuleMethods","activeIndexChange","snapIndexChange","slidesLengthChange","snapGridLengthChange","click","targetEl","hasClass","navigation","nextEl","prevEl","toggleClass","Autoplay","run","$activeSlideEl","autoplay","attr","clearTimeout","timeout","nextTick","autoplayResult","reverseDirection","loopFix","slidePrev","isBeginning","stopOnLastSlide","stop","slideNext","isEnd","cssMode","running","start","pause","paused","waitForTransition","$wrapperEl","addEventListener","onTransitionEnd","onVisibilityChange","document","getDocument","visibilityState","destroyed","removeEventListener","disableOnInteraction","beforeTransitionStart","internal","sliderFirstMove","touchEnd","useDebouncedCallback","func","wait","_this","lastCallTime","useRef","lastInvokeTime","timerId","lastArgs","lastThis","funcRef","mounted","useRAF","window","TypeError","leading","trailing","maxing","maxWait","max","useMemo","invokeFunc","time","args","thisArg","startTimer","pendingFunc","cancelAnimationFrame","requestAnimationFrame","setTimeout","shouldInvoke","timeSinceLastCall","timeSinceLastInvoke","trailingEdge","timerExpired","Date","now","timeWaiting","remainingWait","isInvoking","cancel","isPending","flush"],"mappings":"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","file":"static/js/16.125f9a34.chunk.js","sourcesContent":["import { ObserverInstanceCallback } from './index';\n\nconst ObserverMap = new Map<\n  string,\n  {\n    id: string;\n    observer: IntersectionObserver;\n    elements: Map<Element, Array<ObserverInstanceCallback>>;\n  }\n>();\n\nconst RootIds: WeakMap<Element, string> = new WeakMap();\n\nlet rootId = 0;\n\n/**\n * Generate a unique ID for the root element\n * @param root\n */\nfunction getRootId(root?: Element | null) {\n  if (!root) return '0';\n  if (RootIds.has(root)) return RootIds.get(root);\n  rootId += 1;\n  RootIds.set(root, rootId.toString());\n  return RootIds.get(root);\n}\n\n/**\n * Convert the options to a string Id, based on the values.\n * Ensures we can reuse the same observer when observing elements with the same options.\n * @param options\n */\nexport function optionsToId(options: IntersectionObserverInit) {\n  return Object.keys(options)\n    .sort()\n    .filter((key) => options[key] !== undefined)\n    .map((key) => {\n      return `${key}_${\n        key === 'root' ? getRootId(options.root) : options[key]\n      }`;\n    })\n    .toString();\n}\n\nfunction createObserver(options: IntersectionObserverInit) {\n  // Create a unique ID for this observer instance, based on the root, root margin and threshold.\n  let id = optionsToId(options);\n  let instance = ObserverMap.get(id);\n\n  if (!instance) {\n    // Create a map of elements this observer is going to observe. Each element has a list of callbacks that should be triggered, once it comes into view.\n    const elements = new Map<Element, Array<ObserverInstanceCallback>>();\n    let thresholds: number[] | readonly number[];\n\n    const observer = new IntersectionObserver((entries) => {\n      entries.forEach((entry) => {\n        // While it would be nice if you could just look at isIntersecting to determine if the component is inside the viewport, browsers can't agree on how to use it.\n        // -Firefox ignores `threshold` when considering `isIntersecting`, so it will never be false again if `threshold` is > 0\n        const inView =\n          entry.isIntersecting &&\n          thresholds.some((threshold) => entry.intersectionRatio >= threshold);\n\n        // @ts-ignore support IntersectionObserver v2\n        if (options.trackVisibility && typeof entry.isVisible === 'undefined') {\n          // The browser doesn't support Intersection Observer v2, falling back to v1 behavior.\n          // @ts-ignore\n          entry.isVisible = inView;\n        }\n\n        elements.get(entry.target)?.forEach((callback) => {\n          callback(inView, entry);\n        });\n      });\n    }, options);\n\n    // Ensure we have a valid thresholds array. If not, use the threshold from the options\n    thresholds =\n      observer.thresholds ||\n      (Array.isArray(options.threshold)\n        ? options.threshold\n        : [options.threshold || 0]);\n\n    instance = {\n      id,\n      observer,\n      elements,\n    };\n\n    ObserverMap.set(id, instance);\n  }\n\n  return instance;\n}\n\nexport function observe(\n  element: Element,\n  callback: ObserverInstanceCallback,\n  options: IntersectionObserverInit = {},\n) {\n  if (!element) return () => {};\n  // An observer with the same options can be reused, so lets use this fact\n  const { id, observer, elements } = createObserver(options);\n\n  // Register the callback listener for this element\n  let callbacks = elements.get(element) || [];\n  if (!elements.has(element)) {\n    elements.set(element, callbacks);\n  }\n\n  callbacks.push(callback);\n  observer.observe(element);\n\n  return function unobserve() {\n    // Remove the callback from the callback list\n    callbacks.splice(callbacks.indexOf(callback), 1);\n\n    if (callbacks.length === 0) {\n      // No more callback exists for element, so destroy it\n      elements.delete(element);\n      observer.unobserve(element);\n    }\n\n    if (elements.size === 0) {\n      // No more elements are being observer by this instance, so destroy it\n      observer.disconnect();\n      ObserverMap.delete(id);\n    }\n  };\n}\n","import * as React from 'react';\nimport { IntersectionObserverProps, PlainChildrenProps } from './index';\nimport { observe } from './observers';\n\ntype State = {\n  inView: boolean;\n  entry?: IntersectionObserverEntry;\n};\n\nfunction isPlainChildren(\n  props: IntersectionObserverProps | PlainChildrenProps,\n): props is PlainChildrenProps {\n  return typeof props.children !== 'function';\n}\n\n/**\n ## Render props\n\n To use the `<InView>` component, you pass it a function. It will be called\n whenever the state changes, with the new value of `inView`. In addition to the\n `inView` prop, children also receive a `ref` that should be set on the\n containing DOM element. This is the element that the IntersectionObserver will\n monitor.\n\n If you need it, you can also access the\n [`IntersectionObserverEntry`](https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry)\n on `entry`, giving you access to all the details about the current intersection\n state.\n\n ```jsx\n import { InView } from 'react-intersection-observer';\n\n const Component = () => (\n <InView>\n {({ inView, ref, entry }) => (\n      <div ref={ref}>\n        <h2>{`Header inside viewport ${inView}.`}</h2>\n      </div>\n    )}\n </InView>\n );\n\n export default Component;\n ```\n\n ## Plain children\n\n You can pass any element to the `<InView />`, and it will handle creating the\n wrapping DOM element. Add a handler to the `onChange` method, and control the\n state in your own component. Any extra props you add to `<InView>` will be\n passed to the HTML element, allowing you set the `className`, `style`, etc.\n\n ```jsx\n import { InView } from 'react-intersection-observer';\n\n const Component = () => (\n <InView as=\"div\" onChange={(inView, entry) => console.log('Inview:', inView)}>\n <h2>Plain children are always rendered. Use onChange to monitor state.</h2>\n </InView>\n );\n\n export default Component;\n ```\n */\nexport class InView extends React.Component<\n  IntersectionObserverProps | PlainChildrenProps,\n  State\n> {\n  static displayName = 'InView';\n  static defaultProps = {\n    threshold: 0,\n    triggerOnce: false,\n    initialInView: false,\n  };\n\n  constructor(props: IntersectionObserverProps | PlainChildrenProps) {\n    super(props);\n    this.state = {\n      inView: !!props.initialInView,\n      entry: undefined,\n    };\n  }\n\n  componentDidUpdate(prevProps: IntersectionObserverProps) {\n    // If a IntersectionObserver option changed, reinit the observer\n    if (\n      prevProps.rootMargin !== this.props.rootMargin ||\n      prevProps.root !== this.props.root ||\n      prevProps.threshold !== this.props.threshold ||\n      prevProps.skip !== this.props.skip ||\n      prevProps.trackVisibility !== this.props.trackVisibility ||\n      prevProps.delay !== this.props.delay\n    ) {\n      this.unobserve();\n      this.observeNode();\n    }\n  }\n\n  componentWillUnmount() {\n    this.unobserve();\n    this.node = null;\n  }\n\n  node: Element | null = null;\n  _unobserveCb: (() => void) | null = null;\n\n  observeNode() {\n    if (!this.node || this.props.skip) return;\n    const { threshold, root, rootMargin, trackVisibility, delay } = this.props;\n\n    this._unobserveCb = observe(this.node, this.handleChange, {\n      threshold,\n      root,\n      rootMargin,\n      // @ts-ignore\n      trackVisibility,\n      // @ts-ignore\n      delay,\n    });\n  }\n\n  unobserve() {\n    if (this._unobserveCb) {\n      this._unobserveCb();\n      this._unobserveCb = null;\n    }\n  }\n\n  handleNode = (node?: Element | null) => {\n    if (this.node) {\n      // Clear the old observer, before we start observing a new element\n      this.unobserve();\n\n      if (!node && !this.props.triggerOnce && !this.props.skip) {\n        // Reset the state if we get a new node, and we aren't ignoring updates\n        this.setState({ inView: !!this.props.initialInView, entry: undefined });\n      }\n    }\n    this.node = node ? node : null;\n    this.observeNode();\n  };\n\n  handleChange = (inView: boolean, entry: IntersectionObserverEntry) => {\n    if (inView && this.props.triggerOnce) {\n      // If `triggerOnce` is true, we should stop observing the element.\n      this.unobserve();\n    }\n    if (!isPlainChildren(this.props)) {\n      // Store the current State, so we can pass it to the children in the next render update\n      // There's no reason to update the state for plain children, since it's not used in the rendering.\n      this.setState({ inView, entry });\n    }\n    if (this.props.onChange) {\n      // If the user is actively listening for onChange, always trigger it\n      this.props.onChange(inView, entry);\n    }\n  };\n\n  render() {\n    if (!isPlainChildren(this.props)) {\n      const { inView, entry } = this.state;\n      return this.props.children({ inView, entry, ref: this.handleNode });\n    }\n\n    const {\n      children,\n      as,\n      tag,\n      triggerOnce,\n      threshold,\n      root,\n      rootMargin,\n      onChange,\n      skip,\n      trackVisibility,\n      delay,\n      initialInView,\n      ...props\n    } = this.props;\n\n    return React.createElement(\n      as || tag || 'div',\n      { ref: this.handleNode, ...props },\n      children,\n    );\n  }\n}\n","import * as React from 'react';\nimport { InViewHookResponse, IntersectionOptions } from './index';\nimport { useEffect } from 'react';\nimport { observe } from './observers';\n\ntype State = {\n  inView: boolean;\n  entry?: IntersectionObserverEntry;\n};\n\n/**\n * React Hooks make it easy to monitor the `inView` state of your components. Call\n * the `useInView` hook with the (optional) [options](#options) you need. It will\n * return an array containing a `ref`, the `inView` status and the current\n * [`entry`](https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry).\n * Assign the `ref` to the DOM element you want to monitor, and the hook will\n * report the status.\n *\n * @example\n * ```jsx\n * import React from 'react';\n * import { useInView } from 'react-intersection-observer';\n *\n * const Component = () => {\n *   const { ref, inView, entry } = useInView({\n *       threshold: 0,\n *   });\n *\n *   return (\n *     <div ref={ref}>\n *       <h2>{`Header inside viewport ${inView}.`}</h2>\n *     </div>\n *   );\n * };\n * ```\n */\nexport function useInView({\n  threshold,\n  delay,\n  trackVisibility,\n  rootMargin,\n  root,\n  triggerOnce,\n  skip,\n  initialInView,\n}: IntersectionOptions = {}): InViewHookResponse {\n  const unobserve = React.useRef<Function>();\n  const [state, setState] = React.useState<State>({\n    inView: !!initialInView,\n  });\n  const setRef = React.useCallback(\n    (node) => {\n      if (unobserve.current !== undefined) {\n        unobserve.current();\n        unobserve.current = undefined;\n      }\n\n      // Skip creating the observer\n      if (skip) return;\n\n      if (node) {\n        unobserve.current = observe(\n          node,\n          (inView, entry) => {\n            setState({ inView, entry });\n\n            if (entry.isIntersecting && triggerOnce && unobserve.current) {\n              // If it should only trigger once, unobserve the element after it's inView\n              unobserve.current();\n              unobserve.current = undefined;\n            }\n          },\n          {\n            root,\n            rootMargin,\n            threshold,\n            // @ts-ignore\n            trackVisibility,\n            // @ts-ignore\n            delay,\n          },\n        );\n      }\n    },\n    // We break the rule here, because we aren't including the actual `threshold` variable\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      // If the threshold is an array, convert it to a string so it won't change between renders.\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      Array.isArray(threshold) ? threshold.toString() : threshold,\n      root,\n      rootMargin,\n      triggerOnce,\n      skip,\n      trackVisibility,\n      delay,\n    ],\n  );\n\n  /* eslint-disable-next-line */\n  useEffect(() => {\n    if (!unobserve.current && state.entry && !triggerOnce && !skip) {\n      // If we don't have a ref, then reset the state (unless the hook is set to only `triggerOnce` or `skip`)\n      // This ensures we correctly reflect the current state - If you aren't observing anything, then nothing is inView\n      setState({\n        inView: !!initialInView,\n      });\n    }\n  });\n\n  const result = [setRef, state.inView, state.entry] as InViewHookResponse;\n\n  // Support object destructuring, by adding the specific values.\n  result.ref = result[0];\n  result.inView = result[1];\n  result.entry = result[2];\n\n  return result;\n}\n","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport $ from '../../utils/dom';\nimport { extend, bindModuleMethods, classesToSelector } from '../../utils/utils';\nvar Pagination = {\n  update: function update() {\n    // Render || Update Pagination bullets/items\n    var swiper = this;\n    var rtl = swiper.rtl;\n    var params = swiper.params.pagination;\n    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;\n    var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n    var $el = swiper.pagination.$el; // Current/Total\n\n    var current;\n    var total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n\n    if (swiper.params.loop) {\n      current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);\n\n      if (current > slidesLength - 1 - swiper.loopedSlides * 2) {\n        current -= slidesLength - swiper.loopedSlides * 2;\n      }\n\n      if (current > total - 1) current -= total;\n      if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;\n    } else if (typeof swiper.snapIndex !== 'undefined') {\n      current = swiper.snapIndex;\n    } else {\n      current = swiper.activeIndex || 0;\n    } // Types\n\n\n    if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {\n      var bullets = swiper.pagination.bullets;\n      var firstIndex;\n      var lastIndex;\n      var midIndex;\n\n      if (params.dynamicBullets) {\n        swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);\n        $el.css(swiper.isHorizontal() ? 'width' : 'height', swiper.pagination.bulletSize * (params.dynamicMainBullets + 4) + \"px\");\n\n        if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {\n          swiper.pagination.dynamicBulletIndex += current - swiper.previousIndex;\n\n          if (swiper.pagination.dynamicBulletIndex > params.dynamicMainBullets - 1) {\n            swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;\n          } else if (swiper.pagination.dynamicBulletIndex < 0) {\n            swiper.pagination.dynamicBulletIndex = 0;\n          }\n        }\n\n        firstIndex = current - swiper.pagination.dynamicBulletIndex;\n        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);\n        midIndex = (lastIndex + firstIndex) / 2;\n      }\n\n      bullets.removeClass(params.bulletActiveClass + \" \" + params.bulletActiveClass + \"-next \" + params.bulletActiveClass + \"-next-next \" + params.bulletActiveClass + \"-prev \" + params.bulletActiveClass + \"-prev-prev \" + params.bulletActiveClass + \"-main\");\n\n      if ($el.length > 1) {\n        bullets.each(function (bullet) {\n          var $bullet = $(bullet);\n          var bulletIndex = $bullet.index();\n\n          if (bulletIndex === current) {\n            $bullet.addClass(params.bulletActiveClass);\n          }\n\n          if (params.dynamicBullets) {\n            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {\n              $bullet.addClass(params.bulletActiveClass + \"-main\");\n            }\n\n            if (bulletIndex === firstIndex) {\n              $bullet.prev().addClass(params.bulletActiveClass + \"-prev\").prev().addClass(params.bulletActiveClass + \"-prev-prev\");\n            }\n\n            if (bulletIndex === lastIndex) {\n              $bullet.next().addClass(params.bulletActiveClass + \"-next\").next().addClass(params.bulletActiveClass + \"-next-next\");\n            }\n          }\n        });\n      } else {\n        var $bullet = bullets.eq(current);\n        var bulletIndex = $bullet.index();\n        $bullet.addClass(params.bulletActiveClass);\n\n        if (params.dynamicBullets) {\n          var $firstDisplayedBullet = bullets.eq(firstIndex);\n          var $lastDisplayedBullet = bullets.eq(lastIndex);\n\n          for (var i = firstIndex; i <= lastIndex; i += 1) {\n            bullets.eq(i).addClass(params.bulletActiveClass + \"-main\");\n          }\n\n          if (swiper.params.loop) {\n            if (bulletIndex >= bullets.length - params.dynamicMainBullets) {\n              for (var _i = params.dynamicMainBullets; _i >= 0; _i -= 1) {\n                bullets.eq(bullets.length - _i).addClass(params.bulletActiveClass + \"-main\");\n              }\n\n              bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(params.bulletActiveClass + \"-prev\");\n            } else {\n              $firstDisplayedBullet.prev().addClass(params.bulletActiveClass + \"-prev\").prev().addClass(params.bulletActiveClass + \"-prev-prev\");\n              $lastDisplayedBullet.next().addClass(params.bulletActiveClass + \"-next\").next().addClass(params.bulletActiveClass + \"-next-next\");\n            }\n          } else {\n            $firstDisplayedBullet.prev().addClass(params.bulletActiveClass + \"-prev\").prev().addClass(params.bulletActiveClass + \"-prev-prev\");\n            $lastDisplayedBullet.next().addClass(params.bulletActiveClass + \"-next\").next().addClass(params.bulletActiveClass + \"-next-next\");\n          }\n        }\n      }\n\n      if (params.dynamicBullets) {\n        var dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);\n        var bulletsOffset = (swiper.pagination.bulletSize * dynamicBulletsLength - swiper.pagination.bulletSize) / 2 - midIndex * swiper.pagination.bulletSize;\n        var offsetProp = rtl ? 'right' : 'left';\n        bullets.css(swiper.isHorizontal() ? offsetProp : 'top', bulletsOffset + \"px\");\n      }\n    }\n\n    if (params.type === 'fraction') {\n      $el.find(classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));\n      $el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));\n    }\n\n    if (params.type === 'progressbar') {\n      var progressbarDirection;\n\n      if (params.progressbarOpposite) {\n        progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';\n      } else {\n        progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';\n      }\n\n      var scale = (current + 1) / total;\n      var scaleX = 1;\n      var scaleY = 1;\n\n      if (progressbarDirection === 'horizontal') {\n        scaleX = scale;\n      } else {\n        scaleY = scale;\n      }\n\n      $el.find(classesToSelector(params.progressbarFillClass)).transform(\"translate3d(0,0,0) scaleX(\" + scaleX + \") scaleY(\" + scaleY + \")\").transition(swiper.params.speed);\n    }\n\n    if (params.type === 'custom' && params.renderCustom) {\n      $el.html(params.renderCustom(swiper, current + 1, total));\n      swiper.emit('paginationRender', $el[0]);\n    } else {\n      swiper.emit('paginationUpdate', $el[0]);\n    }\n\n    $el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);\n  },\n  render: function render() {\n    // Render Container\n    var swiper = this;\n    var params = swiper.params.pagination;\n    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;\n    var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n    var $el = swiper.pagination.$el;\n    var paginationHTML = '';\n\n    if (params.type === 'bullets') {\n      var numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n\n      if (swiper.params.freeMode && !swiper.params.loop && numberOfBullets > slidesLength) {\n        numberOfBullets = slidesLength;\n      }\n\n      for (var i = 0; i < numberOfBullets; i += 1) {\n        if (params.renderBullet) {\n          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);\n        } else {\n          paginationHTML += \"<\" + params.bulletElement + \" class=\\\"\" + params.bulletClass + \"\\\"></\" + params.bulletElement + \">\";\n        }\n      }\n\n      $el.html(paginationHTML);\n      swiper.pagination.bullets = $el.find(classesToSelector(params.bulletClass));\n    }\n\n    if (params.type === 'fraction') {\n      if (params.renderFraction) {\n        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);\n      } else {\n        paginationHTML = \"<span class=\\\"\" + params.currentClass + \"\\\"></span>\" + ' / ' + (\"<span class=\\\"\" + params.totalClass + \"\\\"></span>\");\n      }\n\n      $el.html(paginationHTML);\n    }\n\n    if (params.type === 'progressbar') {\n      if (params.renderProgressbar) {\n        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);\n      } else {\n        paginationHTML = \"<span class=\\\"\" + params.progressbarFillClass + \"\\\"></span>\";\n      }\n\n      $el.html(paginationHTML);\n    }\n\n    if (params.type !== 'custom') {\n      swiper.emit('paginationRender', swiper.pagination.$el[0]);\n    }\n  },\n  init: function init() {\n    var swiper = this;\n    var params = swiper.params.pagination;\n    if (!params.el) return;\n    var $el = $(params.el);\n    if ($el.length === 0) return;\n\n    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1) {\n      $el = swiper.$el.find(params.el);\n    }\n\n    if (params.type === 'bullets' && params.clickable) {\n      $el.addClass(params.clickableClass);\n    }\n\n    $el.addClass(params.modifierClass + params.type);\n\n    if (params.type === 'bullets' && params.dynamicBullets) {\n      $el.addClass(\"\" + params.modifierClass + params.type + \"-dynamic\");\n      swiper.pagination.dynamicBulletIndex = 0;\n\n      if (params.dynamicMainBullets < 1) {\n        params.dynamicMainBullets = 1;\n      }\n    }\n\n    if (params.type === 'progressbar' && params.progressbarOpposite) {\n      $el.addClass(params.progressbarOppositeClass);\n    }\n\n    if (params.clickable) {\n      $el.on('click', classesToSelector(params.bulletClass), function onClick(e) {\n        e.preventDefault();\n        var index = $(this).index() * swiper.params.slidesPerGroup;\n        if (swiper.params.loop) index += swiper.loopedSlides;\n        swiper.slideTo(index);\n      });\n    }\n\n    extend(swiper.pagination, {\n      $el: $el,\n      el: $el[0]\n    });\n  },\n  destroy: function destroy() {\n    var swiper = this;\n    var params = swiper.params.pagination;\n    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;\n    var $el = swiper.pagination.$el;\n    $el.removeClass(params.hiddenClass);\n    $el.removeClass(params.modifierClass + params.type);\n    if (swiper.pagination.bullets) swiper.pagination.bullets.removeClass(params.bulletActiveClass);\n\n    if (params.clickable) {\n      $el.off('click', classesToSelector(params.bulletClass));\n    }\n  }\n};\nexport default {\n  name: 'pagination',\n  params: {\n    pagination: {\n      el: null,\n      bulletElement: 'span',\n      clickable: false,\n      hideOnClick: false,\n      renderBullet: null,\n      renderProgressbar: null,\n      renderFraction: null,\n      renderCustom: null,\n      progressbarOpposite: false,\n      type: 'bullets',\n      // 'bullets' or 'progressbar' or 'fraction' or 'custom'\n      dynamicBullets: false,\n      dynamicMainBullets: 1,\n      formatFractionCurrent: function formatFractionCurrent(number) {\n        return number;\n      },\n      formatFractionTotal: function formatFractionTotal(number) {\n        return number;\n      },\n      bulletClass: 'swiper-pagination-bullet',\n      bulletActiveClass: 'swiper-pagination-bullet-active',\n      modifierClass: 'swiper-pagination-',\n      // NEW\n      currentClass: 'swiper-pagination-current',\n      totalClass: 'swiper-pagination-total',\n      hiddenClass: 'swiper-pagination-hidden',\n      progressbarFillClass: 'swiper-pagination-progressbar-fill',\n      progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',\n      clickableClass: 'swiper-pagination-clickable',\n      // NEW\n      lockClass: 'swiper-pagination-lock'\n    }\n  },\n  create: function create() {\n    var swiper = this;\n    bindModuleMethods(swiper, {\n      pagination: _extends({\n        dynamicBulletIndex: 0\n      }, Pagination)\n    });\n  },\n  on: {\n    init: function init(swiper) {\n      swiper.pagination.init();\n      swiper.pagination.render();\n      swiper.pagination.update();\n    },\n    activeIndexChange: function activeIndexChange(swiper) {\n      if (swiper.params.loop) {\n        swiper.pagination.update();\n      } else if (typeof swiper.snapIndex === 'undefined') {\n        swiper.pagination.update();\n      }\n    },\n    snapIndexChange: function snapIndexChange(swiper) {\n      if (!swiper.params.loop) {\n        swiper.pagination.update();\n      }\n    },\n    slidesLengthChange: function slidesLengthChange(swiper) {\n      if (swiper.params.loop) {\n        swiper.pagination.render();\n        swiper.pagination.update();\n      }\n    },\n    snapGridLengthChange: function snapGridLengthChange(swiper) {\n      if (!swiper.params.loop) {\n        swiper.pagination.render();\n        swiper.pagination.update();\n      }\n    },\n    destroy: function destroy(swiper) {\n      swiper.pagination.destroy();\n    },\n    click: function click(swiper, e) {\n      var targetEl = e.target;\n\n      if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && swiper.pagination.$el.length > 0 && !$(targetEl).hasClass(swiper.params.pagination.bulletClass)) {\n        if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;\n        var isHidden = swiper.pagination.$el.hasClass(swiper.params.pagination.hiddenClass);\n\n        if (isHidden === true) {\n          swiper.emit('paginationShow');\n        } else {\n          swiper.emit('paginationHide');\n        }\n\n        swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);\n      }\n    }\n  }\n};","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n/* eslint no-underscore-dangle: \"off\" */\nimport { getDocument } from 'ssr-window';\nimport { nextTick, bindModuleMethods } from '../../utils/utils';\nvar Autoplay = {\n  run: function run() {\n    var swiper = this;\n    var $activeSlideEl = swiper.slides.eq(swiper.activeIndex);\n    var delay = swiper.params.autoplay.delay;\n\n    if ($activeSlideEl.attr('data-swiper-autoplay')) {\n      delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;\n    }\n\n    clearTimeout(swiper.autoplay.timeout);\n    swiper.autoplay.timeout = nextTick(function () {\n      var autoplayResult;\n\n      if (swiper.params.autoplay.reverseDirection) {\n        if (swiper.params.loop) {\n          swiper.loopFix();\n          autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);\n          swiper.emit('autoplay');\n        } else if (!swiper.isBeginning) {\n          autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);\n          swiper.emit('autoplay');\n        } else if (!swiper.params.autoplay.stopOnLastSlide) {\n          autoplayResult = swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);\n          swiper.emit('autoplay');\n        } else {\n          swiper.autoplay.stop();\n        }\n      } else if (swiper.params.loop) {\n        swiper.loopFix();\n        autoplayResult = swiper.slideNext(swiper.params.speed, true, true);\n        swiper.emit('autoplay');\n      } else if (!swiper.isEnd) {\n        autoplayResult = swiper.slideNext(swiper.params.speed, true, true);\n        swiper.emit('autoplay');\n      } else if (!swiper.params.autoplay.stopOnLastSlide) {\n        autoplayResult = swiper.slideTo(0, swiper.params.speed, true, true);\n        swiper.emit('autoplay');\n      } else {\n        swiper.autoplay.stop();\n      }\n\n      if (swiper.params.cssMode && swiper.autoplay.running) swiper.autoplay.run();else if (autoplayResult === false) {\n        swiper.autoplay.run();\n      }\n    }, delay);\n  },\n  start: function start() {\n    var swiper = this;\n    if (typeof swiper.autoplay.timeout !== 'undefined') return false;\n    if (swiper.autoplay.running) return false;\n    swiper.autoplay.running = true;\n    swiper.emit('autoplayStart');\n    swiper.autoplay.run();\n    return true;\n  },\n  stop: function stop() {\n    var swiper = this;\n    if (!swiper.autoplay.running) return false;\n    if (typeof swiper.autoplay.timeout === 'undefined') return false;\n\n    if (swiper.autoplay.timeout) {\n      clearTimeout(swiper.autoplay.timeout);\n      swiper.autoplay.timeout = undefined;\n    }\n\n    swiper.autoplay.running = false;\n    swiper.emit('autoplayStop');\n    return true;\n  },\n  pause: function pause(speed) {\n    var swiper = this;\n    if (!swiper.autoplay.running) return;\n    if (swiper.autoplay.paused) return;\n    if (swiper.autoplay.timeout) clearTimeout(swiper.autoplay.timeout);\n    swiper.autoplay.paused = true;\n\n    if (speed === 0 || !swiper.params.autoplay.waitForTransition) {\n      swiper.autoplay.paused = false;\n      swiper.autoplay.run();\n    } else {\n      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.autoplay.onTransitionEnd);\n      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);\n    }\n  },\n  onVisibilityChange: function onVisibilityChange() {\n    var swiper = this;\n    var document = getDocument();\n\n    if (document.visibilityState === 'hidden' && swiper.autoplay.running) {\n      swiper.autoplay.pause();\n    }\n\n    if (document.visibilityState === 'visible' && swiper.autoplay.paused) {\n      swiper.autoplay.run();\n      swiper.autoplay.paused = false;\n    }\n  },\n  onTransitionEnd: function onTransitionEnd(e) {\n    var swiper = this;\n    if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;\n    if (e.target !== swiper.$wrapperEl[0]) return;\n    swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.autoplay.onTransitionEnd);\n    swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);\n    swiper.autoplay.paused = false;\n\n    if (!swiper.autoplay.running) {\n      swiper.autoplay.stop();\n    } else {\n      swiper.autoplay.run();\n    }\n  }\n};\nexport default {\n  name: 'autoplay',\n  params: {\n    autoplay: {\n      enabled: false,\n      delay: 3000,\n      waitForTransition: true,\n      disableOnInteraction: true,\n      stopOnLastSlide: false,\n      reverseDirection: false\n    }\n  },\n  create: function create() {\n    var swiper = this;\n    bindModuleMethods(swiper, {\n      autoplay: _extends({}, Autoplay, {\n        running: false,\n        paused: false\n      })\n    });\n  },\n  on: {\n    init: function init(swiper) {\n      if (swiper.params.autoplay.enabled) {\n        swiper.autoplay.start();\n        var document = getDocument();\n        document.addEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);\n      }\n    },\n    beforeTransitionStart: function beforeTransitionStart(swiper, speed, internal) {\n      if (swiper.autoplay.running) {\n        if (internal || !swiper.params.autoplay.disableOnInteraction) {\n          swiper.autoplay.pause(speed);\n        } else {\n          swiper.autoplay.stop();\n        }\n      }\n    },\n    sliderFirstMove: function sliderFirstMove(swiper) {\n      if (swiper.autoplay.running) {\n        if (swiper.params.autoplay.disableOnInteraction) {\n          swiper.autoplay.stop();\n        } else {\n          swiper.autoplay.pause();\n        }\n      }\n    },\n    touchEnd: function touchEnd(swiper) {\n      if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {\n        swiper.autoplay.run();\n      }\n    },\n    destroy: function destroy(swiper) {\n      if (swiper.autoplay.running) {\n        swiper.autoplay.stop();\n      }\n\n      var document = getDocument();\n      document.removeEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);\n    }\n  }\n};","import { useRef, useEffect, useMemo } from 'react';\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked, or until the next browser frame is drawn. The debounced function\n * comes with a `cancel` method to cancel delayed `func` invocations and a\n * `flush` method to immediately invoke them. Provide `options` to indicate\n * whether `func` should be invoked on the leading and/or trailing edge of the\n * `wait` timeout. The `func` is invoked with the last arguments provided to the\n * debounced function. Subsequent calls to the debounced function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\n * invocation will be deferred until the next frame is drawn (typically about\n * 16ms).\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `debounce` and `throttle`.\n *\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0]\n *  The number of milliseconds to delay; if omitted, `requestAnimationFrame` is\n *  used (if available, otherwise it will be setTimeout(...,0)).\n * @param {Object} [options={}] The options object.\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.leading=false]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {number} [options.maxWait]\n *  Specify invoking on the trailing edge of the timeout.\n * @param {boolean} [options.trailing=true]\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * const resizeHandler = useDebouncedCallback(calculateLayout, 150);\n * window.addEventListener('resize', resizeHandler)\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * const clickHandler = useDebouncedCallback(sendMail, 300, {\n *   leading: true,\n *   trailing: false,\n * })\n * <button onClick={clickHandler}>click me</button>\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * const debounced = useDebouncedCallback(batchLog, 250, { 'maxWait': 1000 })\n * const source = new EventSource('/stream')\n * source.addEventListener('message', debounced)\n *\n * // Cancel the trailing debounced invocation.\n * window.addEventListener('popstate', debounced.cancel)\n *\n * // Check for pending invocations.\n * const status = debounced.pending() ? \"Pending...\" : \"Ready\"\n */\nexport default function useDebouncedCallback(func, wait, options) {\n    var _this = this;\n    var lastCallTime = useRef(null);\n    var lastInvokeTime = useRef(0);\n    var timerId = useRef(null);\n    var lastArgs = useRef([]);\n    var lastThis = useRef();\n    var result = useRef();\n    var funcRef = useRef(func);\n    var mounted = useRef(true);\n    funcRef.current = func;\n    // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.\n    var useRAF = !wait && wait !== 0 && typeof window !== 'undefined';\n    if (typeof func !== 'function') {\n        throw new TypeError('Expected a function');\n    }\n    wait = +wait || 0;\n    options = options || {};\n    var leading = !!options.leading;\n    var trailing = 'trailing' in options ? !!options.trailing : true; // `true` by default\n    var maxing = 'maxWait' in options;\n    var maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : null;\n    useEffect(function () {\n        mounted.current = true;\n        return function () {\n            mounted.current = false;\n        };\n    }, []);\n    // You may have a question, why we have so many code under the useMemo definition.\n    //\n    // This was made as we want to escape from useCallback hell and\n    // not to initialize a number of functions each time useDebouncedCallback is called.\n    //\n    // It means that we have less garbage for our GC calls which improves performance.\n    // Also, it makes this library smaller.\n    //\n    // And the last reason, that the code without lots of useCallback with deps is easier to read.\n    // You have only one place for that.\n    var debounced = useMemo(function () {\n        var invokeFunc = function (time) {\n            var args = lastArgs.current;\n            var thisArg = lastThis.current;\n            lastArgs.current = lastThis.current = null;\n            lastInvokeTime.current = time;\n            return (result.current = funcRef.current.apply(thisArg, args));\n        };\n        var startTimer = function (pendingFunc, wait) {\n            if (useRAF)\n                cancelAnimationFrame(timerId.current);\n            timerId.current = useRAF ? requestAnimationFrame(pendingFunc) : setTimeout(pendingFunc, wait);\n        };\n        var shouldInvoke = function (time) {\n            if (!mounted.current)\n                return false;\n            var timeSinceLastCall = time - lastCallTime.current;\n            var timeSinceLastInvoke = time - lastInvokeTime.current;\n            // Either this is the first call, activity has stopped and we're at the\n            // trailing edge, the system time has gone backwards and we're treating\n            // it as the trailing edge, or we've hit the `maxWait` limit.\n            return (!lastCallTime.current ||\n                timeSinceLastCall >= wait ||\n                timeSinceLastCall < 0 ||\n                (maxing && timeSinceLastInvoke >= maxWait));\n        };\n        var trailingEdge = function (time) {\n            timerId.current = null;\n            // Only invoke if we have `lastArgs` which means `func` has been\n            // debounced at least once.\n            if (trailing && lastArgs.current) {\n                return invokeFunc(time);\n            }\n            lastArgs.current = lastThis.current = null;\n            return result.current;\n        };\n        var timerExpired = function () {\n            var time = Date.now();\n            if (shouldInvoke(time)) {\n                return trailingEdge(time);\n            }\n            // https://github.com/xnimorz/use-debounce/issues/97\n            if (!mounted.current) {\n                return;\n            }\n            // Remaining wait calculation\n            var timeSinceLastCall = time - lastCallTime.current;\n            var timeSinceLastInvoke = time - lastInvokeTime.current;\n            var timeWaiting = wait - timeSinceLastCall;\n            var remainingWait = maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n            // Restart the timer\n            startTimer(timerExpired, remainingWait);\n        };\n        var func = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var time = Date.now();\n            var isInvoking = shouldInvoke(time);\n            lastArgs.current = args;\n            lastThis.current = _this;\n            lastCallTime.current = time;\n            if (isInvoking) {\n                if (!timerId.current && mounted.current) {\n                    // Reset any `maxWait` timer.\n                    lastInvokeTime.current = lastCallTime.current;\n                    // Start the timer for the trailing edge.\n                    startTimer(timerExpired, wait);\n                    // Invoke the leading edge.\n                    return leading ? invokeFunc(lastCallTime.current) : result.current;\n                }\n                if (maxing) {\n                    // Handle invocations in a tight loop.\n                    startTimer(timerExpired, wait);\n                    return invokeFunc(lastCallTime.current);\n                }\n            }\n            if (!timerId.current) {\n                startTimer(timerExpired, wait);\n            }\n            return result.current;\n        };\n        func.cancel = function () {\n            if (timerId.current) {\n                useRAF ? cancelAnimationFrame(timerId.current) : clearTimeout(timerId.current);\n            }\n            lastInvokeTime.current = 0;\n            lastArgs.current = lastCallTime.current = lastThis.current = timerId.current = null;\n        };\n        func.isPending = function () {\n            return !!timerId.current;\n        };\n        func.flush = function () {\n            return !timerId.current ? result.current : trailingEdge(Date.now());\n        };\n        return func;\n    }, [leading, maxing, wait, maxWait, trailing, useRAF]);\n    return debounced;\n}\n"],"sourceRoot":""}